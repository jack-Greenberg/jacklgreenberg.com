{
    "data" :  {
    "title": "NEATO Gauntlet",
    "date": "2020-05-13 20:20:30 -0700 PDT",
    "year": "2020",
    "draft": "false",
    "featured": "false",
    "image": "images/gauntlet-contour.svg",
    "permalink" : "https://jacklgreenberg.com/projects/neato-gauntlet/index.json",
    "content" : "\nThe objective of this project (the final of my Olin class _Quantitative Engineering Analysis_) was to navigate a simulated Roomba-like robot through a world called __The Gauntlet__, avoiding obstacles (boxes) until finally reaching the goal (cylinder).\n\n{{\u003c\n    figure src=\"images/gauntlet.png\"\n    caption=\"The Gauntlet\"\n\u003e}}\n\n\n## The Code\n\n### RANSAC\n\nThe RANSAC, or *Random Sample Consensus* algorithm is a method of identifying features from a dataset. It works by selecting a set of points and fitting a model to them. The algorithm then separates the original dataset into a set of *inliers*, which are points that fall within a threshold *d* of the model, and a set of *outliers*. The process is repeated *n* times until the algorithm has determined the best fit of the model, and outputs that.\n\nAt this point, RANSAC has output a single feature with a given set of inliers, and so it runs again with the leftover outliers to identify a second set of features, and then a third, and so on, until it has identified all the major features of the data.\n\n#### Fitting Lines\n\nTo fit a line, the algorithm chooses two points:\n\n```matlab\npoints = datasample(data, 2, 'Replace', false);\nP1 = points(1,:); P2 = points(2,:);\n```\n\nIt calculates the vector between these two points and its orthogonal vector, and then for every other point in the dataset, it performs the dot product of the point and the unit orthogonal vector to get the perpendicular distance from the point to the line formed by `P1` and `P2`:\n\n```matlab\nV = P2 - P1;\nV_unit = V./norm(V);\nV_Orth = [-V(2) V(1)];\nV_Orth_unit = V_Orth./norm(V_orth);\n\nperpendicular_distances = (data - P2) * V_Orth_unit';\ninliers = abs(perpendicular_distances) \u003e d; % d is the threshold distance for inliers\n```\n\nIt also finds the biggest gap in the our model, because if it is too big, it should be discarded:\n\n```matlab\nbiggest_gap = max(diff(sort(diffs(inliers,:) * V_unit')));\n```\n\n#### Fitting Circles\n\nFitting circles is more challenging. When fitting lines, it is easy to just find the perpendicular distance from any point to that line, but with circles, I needed to be more clever.\n\nA circle can be defined by three points, so the algorithm chooses 3 points from the dataset and splits them in *x* and *y* components:\n\n```matlab\npoints = datasample(data, 3, 'Replace', false);\nPx = points(:,1); Py = points(:,2);\n```\n\nIt then runs a linear regression in the form of a linear systems of equations to solve for the coefficients of the circle in general form:\n\n```matlab\nA = [Px, Py, ones(size(Px))];\nB  = -Px.^2 - Py.^2;\nc = A \\ B;\n\n% x_c and y_c are the x and y components of the circle's center\nx_c = -c(1)/2;\ny_c = -c(2)/2;\n\n% r is the radius of the circle\nr = sqrt(x_c.^2 + yc.^2 - w(3));\n```\n\nOnce it has the center and radius of the circle, it calculates the distance from any point to the circle by finding the distance to the center of the circle, and subtracts the radius to get the distance from the edge of the circle:\n\n```matlab\ndistance = abs(sqrt((data(:,1) - x_c).^2 + (data(:,2) - y_c).^2) - r);\ninliers = (distance \u003c d);\n```\n\nThere are two issues that initially came up with this implementation:\n\n1. The algorithm would sometimes treat straight lines as arcs of circles with ***huge*** radii, on the scale of 10\u003csup\u003e6\u003c/sup\u003e, and\n2. The circle would identify right angles as arcs of a circle.\n\nTo solve the first issue, since I knew the approximate size of the circle, I ruled out models with radii too far from the goal. That part was easier. The second issue required some more ingenuity.\n\nIn theory, if a set of data points fit a model, then any subset of those points would fit the same model just as well. I used this fact to solve the right-angle fitting issue by performing the RANSAC circle detector once more on the set of inliers generated the first time. If the original fit of a circle was *correct*, then the center and radius of the new circle will be roughly the same. However, if it is a right angle, it is more likely that the center of the newly generated circle will be significantly different than the original, so we can rule it out as a circle.\n\n\n\n### Generating Vector Fields\n\nNow that I had a set of boundaries and a goal from our dataset, I needed a way to generate a map that the NEATO can follow. For this challenge, I implemented a vector field/gradient descent algorithm to have the NEATO navigate the gauntlet. To generate the map, I used the equation:\n\n{{\u003cmath\n    class=\"math\"\n    content=\"z = ln \\sqrt{(x-x_n)^{2}+(y-y_n)^{2}}\"\n\u003e}}\n\nI added multiple of these terms together to generate a composite map of the NEATO's surroundings. If the term is *positive*, then we get a \"sink\", and if the term is *negative* we get a \"source\". When it comes time for the NEATO to choose a path with gradient descent, it will be attraced to the sinks and repelled from the sources.\n\nI took three different approaches to generating the sinks and sources. First, I just use the end points of the best fit lines as sources and the center of the circle as sinks. The issue with this was that on big lines, the NEATO would find paths through the middle of a wall, and would then collide with said wall.\n\nThe next thing I tried was having *n* points between the two endpoints of every line and making each of those sources. The problem there was in the density of sources. Longer lines, like the boundary of the Gauntlet, would have points spaced out every .25 meters, but short lines like the edge of a box would have points spaced out every .025 meters. This was an issue because boundaries need to all have the same weights or else the ones with less weight/density will be treated as acceptable for finding paths.\n\nThe final, successful, approach I took was instead calculating the length of the lines and generating a set of equally spaced points along the line to create sources. For the circle, I found equally spaced points around the circumference.\n\nThe final equation was:\n\n\n\n\n\n\n\n\n\n...complicated. I like to embed mathematics with \u003cimg src=\"https://i.stack.imgur.com/t5VF4.png\" height=\"16px\" /\u003e, as you will see above. I knew the equation had a lot of sources and sinks (around 20,000), so instead of manually writing it all out, I wrote a Python script to automate it for me. In [mathtex.py](https://github.com/jack-greenberg/qea-gauntlet/blob/master/mathtex.py) I import all the sources and sinks from CSV files and process them into LaTeX. My thinking was that I would then copy the result into Overleaf, a LaTeX compiler, but when I tried pasting into Overleaf, it said there was an error, and then my browser crashed. If you'd like to view the raw LaTeX, you can run `python3 mathtex.py` or you can look at the CSV files to see the points for yourself.\n\n\n\n### Gradient Descent\n\nAfter I generated the equation, it was time to get the NEATO to actually move. In order to do this, I used a *gradient descent* method. The algorithm works by assessing the current position of the NEATO using ROS's `/odom` topic (which gets the position of the NEATO and it's orientation in the form of a quarternion), rotating in the opposite direction of the gradient vector at its current point, and then moving along some proportion of the length of the gradient vector.\n\nThe equation to calculate the next point is:\n\n{{\u003c math\n    class=\"math\"\n    content=\"r_{n+1} = r_{n} - \\lambda_{n} \\cdot \\nabla V\"\n\u003e}}\n\nwhere \u003cimg src=\"https://render.githubusercontent.com/render/math?math=\\lambda_{n}\"\u003e is a scalar and determined by \u003cimg src=\"https://render.githubusercontent.com/render/math?math=\\lambda_{n%2b1} = \\delta \\lambda_{n}\"\u003e and \u003cimg src=\"https://render.githubusercontent.com/render/math?math=\\delta\"\u003e is some scalar. The code to make the NEATO rotate is as follows:\n\n```matlab\nfunction rotate(theta)\n    global pubvel message stopMessage\n    % pubvel is the ROS publisher for /raw-vel\n    % message is a ROS Message used for sending wheel speeds\n    % stopMessage is a ROS Message with wheel speeds of 0 used to\n    %   stop the NEATO\n\n    wheel_speed = .2;\n    wheel_base = 0.235; % Distance between the NEATO's wheels\n\n\t% To make the NEATO rotate, we get the sign of the angle and multiply the\n\t% left wheel by -1 to make the wheels rotate in opposite directions.\n    message.Data = [-1*sign(theta)*wheel_speed, sign(theta)*wheel_speed];\n    send(pubvel, message);\n\n\t% This next chunk uses the elapsed time from the start with the NEATO's\n\t% angular velocity to determine when to stop.\n    start = rostime('now');\n    while (1)\n        current = rostime('now');\n        elapsed = current - start;\n\n        if elapsed.seconds \u003e= abs(theta/(2*wheel_speed / wheel_base))\n            send(pubvel, stopMessage);\n            break\n        end\n    end\nend\n```\n\nThe code for making the NEATO travel in a straight line is very similar, except the wheels rotate in the same direction:\n\n```matlab\nfunction travel(distance)\n    global pubvel message stopMessage bump_sub\n\n    wheel_speed = .2;\n\n    message.Data = [wheel_speed, wheel_speed];\n    send(pubvel, message);\n\n\tstart = rostime('now');\n    while (1)\n        current = rostime('now');\n        elapsed = current - start;\n\n        % A bump sensor tells the NEATO to stop if it bumps into something.\n        bumpMessage = receive(bump_sub);\n        if any(bumpMessage.Data)\n            send(pubvel, stopMessage);\n            break;\n        end\n\n\n        if elapsed.seconds \u003e= abs(distance/wheel_speed)\n            send(pubvel, stopMessage);\n            break\n        end\n    end\nend\n```\n\nIn the end, the NEATO took approximately 45 seconds to reach its goal. It's slowness is due in part to the slow wheel velocity of 0.2 m/s, and in part because it was doing so much computational work in between each movement.\n\n## Final Video\n\n{{\u003c youtube id=\"NQd-fZsqmDU\" autoplay=\"false\" \u003e}}\n"
}
 
}
